// package main

// import (
// 	"fmt"
// 	"io"
// 	"os"
// 	"strings"

// 	"log"

// 	"net"
// )

// func main() {
// 	arguments := os.Args
// 	if len(arguments) == 1 {
// 		fmt.Println("Please provide a port number!")
// 		return
// 	}

// 	PORT := ":" + arguments[1]
// 	l, err := net.Listen("tcp4", PORT)
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// 	defer l.Close()

// 	for {
// 		c, err := l.Accept()
// 		if err != nil {
// 			fmt.Println(err)
// 			return
// 		}
// 		go handleConnection(c)
// 	}
// }

// func handleConnection(c net.Conn) {
// 	fmt.Printf("Serving %s\n", c.RemoteAddr().String())
// 	packet := make([]byte, 4096)
// 	tmp := make([]byte, 4096)
// 	defer c.Close()
// 	for {
// 		_, err := c.Read(tmp)
// 		if err != nil {
// 			if err != io.EOF {
// 				fmt.Println("read error:", err)
// 			}
// 			println("END OF FILE")
// 			break
// 		}
// 		packet = append(packet, tmp...)
// 		if strings.Split(string(tmp), " ")[0] == "CONNECT" {
// 			fmt.Println("connect")
// 			packet = []byte("HTTP/1.1 200 OK\n\n")
// 			num, _ := c.Write(packet)
// 			fmt.Printf("Wrote back %d bytes, the payload is %s\n", num, string(packet))
// 			packet = make([]byte, 4096)
// 			continue
// 		} else {
// 			fmt.Printf("Not Connect, %s\n", strings.Split(string(tmp), " ")[0])
// 		}
// 	}
// 	num, _ := c.Write(packet)

// 	fmt.Printf("Wrote back %d bytes, the payload is %s\n", num, string(packet))

// }

// package main

// import (
// 	"fmt"
// 	"io"
// 	"net"
// 	"net/http"
// 	"time"
// )

// func handleTunneling(w http.ResponseWriter, req *http.Request) {
// 	fmt.Printf("%+v\n\n", req)
// 	if req.Method != http.MethodConnect {
// 		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
// 		return
// 	}

// 	// Establish connection to the target host
// 	destConn, err := net.DialTimeout("tcp", req.Host, 10*time.Second)
// 	if err != nil {
// 		http.Error(w, err.Error(), http.StatusServiceUnavailable)
// 		return
// 	}
// 	defer destConn.Close()

// 	// Respond to the client that connection is established
// 	w.WriteHeader(http.StatusOK)
// 	hijacker, ok := w.(http.Hijacker)
// 	if !ok {
// 		http.Error(w, "Hijacking not supported", http.StatusInternalServerError)
// 		return
// 	}
// 	clientConn, bufrw, err := hijacker.Hijack()
// 	if err != nil {
// 		http.Error(w, err.Error(), http.StatusInternalServerError)
// 		return
// 	}
// 	defer clientConn.Close()

// 	// Tunnel traffic between client and target
// 	go transfer(destConn, bufrw)
// 	go transfer(clientConn, destConn)
// }

// func transfer(destination io.WriteCloser, source io.Reader) {
// 	defer destination.Close()
// 	// defer source.
// 	io.Copy(destination, source)
// }

// func main() {
// 	// Set up handler for CONNECT requests
// 	http.HandleFunc("/", handleTunneling)

// 	// Start the server
// 	fmt.Println("Server started on :8080")
// 	err := http.ListenAndServe(":8080", nil)
// 	if err != nil {
// 		panic(err)
// 	}
// }

// package main

// import (
// 	"bufio"
// 	"encoding/base64"
// 	"flag"
// 	"io"
// 	"log"
// 	"net"
// 	"net/http"
// 	"strings"
// 	"time"
// )

// func transfer(destination io.WriteCloser, source io.ReadCloser) {
// 	defer destination.Close()
// 	defer source.Close()
// 	io.Copy(destination, source)
// }

// func main() {
// 	host := flag.String("host", ":8080", "host proxy server")
// 	auth := flag.String("auth", "", "authentication to for client to connect proxy, ex: username:password")

// 	flag.Parse()

// 	listener, err := net.Listen("tcp", *host)
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// 	defer listener.Close()

// 	for {
// 		conn, err := listener.Accept()
// 		if err != nil {
// 			log.Fatal(err)
// 		}

// 		go func(c net.Conn) {
// 			br := bufio.NewReader(c)
// 			req, err := http.ReadRequest(br)
// 			if err != nil {
// 				log.Println("buffer: ", err)
// 				return
// 			}

// 			if req.Method == http.MethodConnect {
// 				if *auth != "" {
// 					clientAuth := req.Header.Get("Proxy-Authorization")
// 					if clientAuth == "" {
// 						response := &http.Response{
// 							StatusCode: http.StatusProxyAuthRequired,
// 							ProtoMajor: 1,
// 							ProtoMinor: 1,
// 						}
// 						response.Write(c)
// 						c.Close()
// 						return
// 					}

// 					serverAuth := "Basic " + base64.StdEncoding.EncodeToString([]byte(*auth))
// 					if clientAuth != serverAuth {
// 						response := &http.Response{
// 							StatusCode: http.StatusUnauthorized,
// 							ProtoMajor: 1,
// 							ProtoMinor: 1,
// 						}
// 						response.Write(c)
// 						c.Close()
// 						return
// 					}
// 				}

// 				response := &http.Response{
// 					StatusCode: 200,
// 					ProtoMajor: 1,
// 					ProtoMinor: 1,
// 				}
// 				response.Write(c)

// 				destConn, err := net.DialTimeout("tcp", req.URL.Host, 10*time.Second)
// 				if err != nil {
// 					response := &http.Response{
// 						StatusCode: http.StatusRequestTimeout,
// 						ProtoMajor: 1,
// 						ProtoMinor: 1,
// 					}
// 					response.Write(c)
// 					return
// 				}

// 				go transfer(destConn, c)
// 				go transfer(c, destConn)

// 			} else {
// 				response := &http.Response{
// 					StatusCode: http.StatusRequestTimeout,
// 					ProtoMajor: 1,
// 					ProtoMinor: 1,
// 					Body:       io.NopCloser(strings.NewReader("hello world")),
// 				}
// 				response.Write(c)
// 				c.Close()
// 				return
// 			}
// 		}(conn)
// 	}
// }

package main

import (
	// "crypto/ecdsa"
	// "crypto/ecdsa"
	// "crypto/elliptic"
	// "crypto/sha256"

	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/hex"
	"encoding/pem"
	"log"
	"math/big"
	"strconv"
	"strings"

	// "crypto/ecdsa"
	// "crypto/ecdsa"
	"crypto/tls"
	"fmt"
	"io"
	"os"
	"time"

	// "log"
	"net"
	"net/http"
	"net/http/httputil"
	// "net/url"
)

type ProxyHandler struct{}

var proxy *httputil.ReverseProxy

func (p ProxyHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	if req.Method == http.MethodConnect {
		p.handleConnect(w, req)
		return
	}
	// http.DefaultServeMux.ServeHTTP(w, req) // Handle other requests as usual
	p.handleRequest(w, req)
}

func (p ProxyHandler) handleRequest(w http.ResponseWriter, req *http.Request) {
	proxy.ServeHTTP(w, req)
}

func (p ProxyHandler) handleConnect(w http.ResponseWriter, req *http.Request) {
	destConn, err := net.Dial("tcp", req.URL.Host)
	if err != nil {
		http.Error(w, err.Error(), http.StatusServiceUnavailable)
		return
	}
	w.WriteHeader(http.StatusOK)
	hijacker, ok := w.(http.Hijacker)
	if !ok {
		http.Error(w, "Hijacking not supported", http.StatusInternalServerError)
		return
	}
	clientConn, readerWriter, err := hijacker.Hijack()
	if err != nil {
		http.Error(w, err.Error(), http.StatusServiceUnavailable)
		return
	}
	fmt.Printf("readerWriter: %+v\n", readerWriter)
	// go transfer(destConn, clientConn)
	// go transfer(clientConn, destConn)

	// testing

	// cert, err := tls.LoadX509KeyPair("/Users/erikmanor/SSL/test_proxy/proxy.crt", "/Users/erikmanor/SSL/test_proxy/proxy.key")
	// if err != nil {
	// 	fmt.Println(err)
	// 	return
	// }
	// tlsConfig := tls.Config{Certificates: []tls.Certificate{cert}}

	rootCert, rootKey, rootErr := loadRootCert("/Users/erikmanor/SSL/origin/9.2024/rootCA.crt", "/Users/erikmanor/SSL/origin/9.2024/rootCA.key")
	if rootErr != nil {
		fmt.Printf("Error loadRootCert(): %+v\n", rootErr)
	}
	leafCert, _, leafKey, leafErr := generateLeafCertificate(rootCert, rootKey.(*rsa.PrivateKey))
	if leafErr != nil {
		fmt.Printf("Error generateLeafCertificate(): %+v\n", leafErr)
	}

	// fmt.Printf("leafBytes: %+v\n", leafBytes)
	// fmt.Printf("leafKey: %+v\n", leafKey)

	// cert, err := tls.X509KeyPair(block.Bytes, x509.MarshalPKCS1PrivateKey(leafKey))
	// if err != nil {
	// 	fmt.Printf("Error X509KeyPair(): %+v\n", err)
	// }
	// tlsConfig := tls.Config{Certificates: []tls.Certificate{cert}}
	tlsCert := tls.Certificate{
		Certificate: [][]byte{leafCert.Raw},
		PrivateKey:  leafKey,
		Leaf:        leafCert,
	}
	tlsConfig := tls.Config{
		Certificates: []tls.Certificate{tlsCert},
		MaxVersion:   tls.VersionTLS12,
	}

	tlsConn := tls.Server(clientConn, &tlsConfig)
	// fmt.Printf("tlsConn: %+v\n", tlsConn)
	err = tlsConn.Handshake()
	if err != nil {
		fmt.Printf("Handshake Error: %+v\n", err)
		return
	}

	fmt.Printf("%+v\n", destConn)

	/*
		// Max tcp packet size is 65k, typical network equipment restrict MTU to 1500 bytes
		// use 2048, if greater copy to bytebuffer as needed
		b := make([]byte, BUFFER_INC)

		read, readErr := tlsConn.Read(b)
		fmt.Printf("Read: %v, ReadErr: %v\n", read, readErr)
		fmt.Printf("%+v\n", string(b))

		if read >= BUFFER_INC {
			buffer := bytes.Buffer{}
			buffer.Write(b)
			for {

				innerRead, readErr := tlsConn.Read(b)
				fmt.Printf("Read Extra: %v, ReadErr: %v\n", innerRead, readErr)
				fmt.Printf("%+v\n", string(b))
				buffer.Write(b[0:innerRead])
				read += innerRead
				if innerRead < BUFFER_INC {
					//b = buffer.Bytes()
					break
				}
			}
			fmt.Printf("\nFinal []byte size: %v\n", len(b))
			b = buffer.Bytes()
		}
		fmt.Printf("\nFinal []byte size2: %v\n", len(b))
		// read = len(b)
		fmt.Printf("\n\n%s\n\n", string(b))
		// byteReader := bytes.NewReader(b)
		// bufReader := bufio.NewReader(byteReader)

		httpMsg := parseRequestMessage(b[0:read]) //, read)
	*/
	httpMsg := readFromConnection(tlsConn)
	b := httpMsg.RawMessage
	read := httpMsg.RawMessageLen
	httpMsg = parseRequestMessage(b)
	httpMsg.RawMessage = b
	httpMsg.RawMessageLen = read

	fmt.Printf("\n\nStartLine: %v %v %v\n", httpMsg.Method, httpMsg.Uri, httpMsg.Version)

	// REAL WAY kind of
	originTlsConn, originErr := tls.Dial("tcp", "emanor-oie.oktapreview.com:443", nil)
	// originTlsConn, originErr := tls.Dial("tcp", "gw.oktamanor.net:443", nil)
	if originErr != nil {
		fmt.Printf("originErr: %+v\n", originErr)
	}
	originTlsConn.SetReadDeadline(time.Now().Add(time.Minute))
	originTlsConn.Write(b[0:read])

	// originRead, originReadErr := originTlsConn.Read(b)
	// fmt.Printf("originRead: %v, originReadErr: %v\n", originRead, originReadErr)
	// fmt.Printf("%+v\n", string(b[0:originRead]))
	// // hexString := hex.EncodeToString(b[0:originRead])
	// // fmt.Printf("\n%+v\n\n", hexString)

	// if originRead >= len(b) {
	// 	buffer := bytes.Buffer{}
	// 	buffer.Write(b)
	// 	for {

	// 		innerRead, readErr := originTlsConn.Read(b)
	// 		fmt.Printf("originRead Extra: %v, originReadErr: %v\n", innerRead, readErr)
	// 		fmt.Printf("%+v\n", string(b))
	// 		buffer.Write(b[0:innerRead])
	// 		originRead += innerRead
	// 		if innerRead < BUFFER_INC {
	// 			//b = buffer.Bytes()
	// 			break
	// 		}
	// 	}

	// 	b = buffer.Bytes()
	// 	fmt.Printf("\nFinal []byte size: %v\n", len(b))
	// }

	// httpMsg = parseResponseMessage(b[0:originRead])

	httpMsg = readFromConnection(originTlsConn)
	b = httpMsg.RawMessage
	originRead := httpMsg.RawMessageLen
	httpMsg = parseResponseMessage(b)
	httpMsg.RawMessage = b
	httpMsg.RawMessageLen = originRead

	fmt.Printf("\n\nStatusLine: %v %v %v\n", httpMsg.Version, httpMsg.StatusCode, httpMsg.ReasonPhrase)

	//test clear buffer if needed
	// for i := 0; !bytes.Equal(b[originRead-4:originRead], []byte("\r\n\r\n")) && i < 100; i++ {
	// 	b2 := []byte{}
	// 	originRead2, originReadErr := originTlsConn.Read(b2)
	// 	fmt.Printf("originRead2: %v, originReadErr2: %v\n", originRead2, originReadErr)
	// 	fmt.Printf("%+v\n", string(b2[0:originRead2]))
	// 	hexString = hex.EncodeToString(b2[0:originRead2])
	// 	fmt.Printf("\n%+v\n", hexString)
	// 	for i := 0; i < originRead2; i++ {
	// 		b[originRead] = b2[i]
	// 		originRead++
	// 	}
	// }
	// for i := 0; i < 2; i++ {

	// 	b2 := []byte{}
	// 	originRead2, originReadErr := originTlsConn.Read(b2)
	// 	fmt.Printf("originRead2: %v, originReadErr2: %v\n", originRead2, originReadErr)
	// 	fmt.Printf("%+v\n", string(b2[0:originRead2]))
	// 	hexString = hex.EncodeToString(b2[0:originRead2])
	// 	fmt.Printf("\n%+v\n", hexString)

	// }
	//end test clear read

	// if originReadErr != nil && !strings.Contains(originReadErr.Error(), "remote error: tls: user canceled") {
	// 	break
	// }

	// newLine := []byte("\r\n")
	// fmt.Printf("newLine sz: %v\n", len(newLine))
	// b[originRead] = newLine[0]
	// b[originRead+1] = newLine[1]

	// clientWritten, clientWriteErr := tlsConn.Write(b[0 : originRead+2])
	clientWritten, clientWriteErr := tlsConn.Write(b[0:originRead])
	fmt.Printf("clientWritten: %v, clientWriteErr: %v\n", clientWritten, clientWriteErr)

	// check for last chunk
	originRead, originReadErr := originTlsConn.Read(b)
	fmt.Printf("\nCHK LAST CHUNKoriginRead: %v, originReadErr: %v\n", originRead, originReadErr)
	fmt.Printf("%+v\n", string(b[0:originRead]))

	// clientWritten, clientWriteErr = tlsConn.Write([]byte("0\r\n\r\n"))
	clientWritten, clientWriteErr = tlsConn.Write(b[0:originRead])
	fmt.Printf("clientWritten END: %v, clientWriteErr END: %v\n", clientWritten, clientWriteErr)

	// if clientWriteErr != nil && !strings.Contains(clientWriteErr.Error(), "remote error: tls: user canceled") {
	// 	break
	// }

	// var originWriteBuf bytes.Buffer // Create a new buffer
	// originWriteBuf.Write(b)
	// 	originWriter := io.Writer(&originWriteBuf)
	for {

		// clientRead, clientReadErr := tlsConn.Read(b)
		// fmt.Printf("clientRead: %v, clientReadErr: %v\n", clientRead, clientReadErr)
		// if clientReadErr != nil && !strings.Contains(clientReadErr.Error(), "remote error: tls: user canceledBAD") {
		// 	break
		// }

		// fmt.Printf("%+v\n", string(b[0:clientRead]))
		// hexString := hex.EncodeToString(b[0:clientRead])
		// fmt.Printf("\n%+v\n", hexString)

		// httpMsg := parseRequestMessage(b[0:clientRead]) //, read)

		httpMsg := readFromConnection(tlsConn)
		b := httpMsg.RawMessage
		clientRead := httpMsg.RawMessageLen
		httpMsg = parseRequestMessage(b)
		httpMsg.RawMessage = b
		httpMsg.RawMessageLen = clientRead

		fmt.Printf("\n\nhttps:\n%+v\n", httpMsg)

		//test clear buffer if needed
		// b2 := []byte{}
		// originRead2, originReadErr := originTlsConn.Read(b2)
		// fmt.Printf("originRead2: %v, originReadErr: %v\n", originRead2, originReadErr)
		// fmt.Printf("%+v\n", string(b2[0:originRead2]))
		// hexString = hex.EncodeToString(b2[0:originRead2])
		// fmt.Printf("\n%+v\n", hexString)
		//end test clear read

		originWritten, originWriteError := originTlsConn.Write(b[0:clientRead])
		fmt.Printf("originWritten: %v, originWriteError: %v\n", originWritten, originWriteError)
		fmt.Printf("%+v\n", string(b[0:originWritten]))
		if originWriteError != nil && !strings.Contains(originWriteError.Error(), "remote error: tls: user canceledBAD") {
			break
		}

		var originRead int
		// var originReadErr error
		for i := 0; i < 4; i++ {

			// originRead, originReadErr = originTlsConn.Read(b)
			// fmt.Printf("originRead LOOP: %v, originReadErr: %v\n", originRead, originReadErr)
			// fmt.Printf("%+v\n", string(b[0:originRead]))
			// hexString := hex.EncodeToString(b[0:originRead])
			// // fmt.Printf("\n%+v\n", hexString)

			httpMsg = readFromConnection(originTlsConn)
			b = httpMsg.RawMessage
			originRead = httpMsg.RawMessageLen

			if hex.EncodeToString(b[0:originRead]) == "300d0a0d0a" {
				break
			}

			httpMsg = parseResponseMessage(b)
			httpMsg.RawMessage = b
			httpMsg.RawMessageLen = originRead
			// hexString := hex.EncodeToString(b[0:originRead])

			clientWritten, clientWriteErr := tlsConn.Write(b[0:originRead])
			// clientWritten, clientWriteErr := tlsConn.Write(b)
			fmt.Printf("clientWritten LOOP: %v, clientWriteErr: %v\n", clientWritten, clientWriteErr)
			fmt.Printf("Last bytes: -%v-,-%v-\n", int(b[originRead-2]), int(b[originRead-1]))

			// if hexString == "300d0a0d0a" {
			// 	break
			// }

			// httpMsg = parseResponseMessage(b[0:originRead])
			fmt.Printf("\n\nStatusLine: %v %v %v\n", httpMsg.Version, httpMsg.StatusCode, httpMsg.ReasonPhrase)
			// if originReadErr != nil && !strings.Contains(originReadErr.Error(), "remote error: tls: user canceledBAD") {
			// 	break
			// }

		}

		// newLine := []byte("\r\n")
		// fmt.Printf("newLine sz: %v\n", len(newLine))
		// b[originRead] = newLine[0]
		// b[originRead+1] = newLine[1]

		clientWritten, clientWriteErr := tlsConn.Write(b[0:originRead])
		// clientWritten, clientWriteErr := tlsConn.Write(b)
		fmt.Printf("clientWritten: %v, clientWriteErr: %v\n", clientWritten, clientWriteErr)
		fmt.Printf("Last bytes: -%v-,-%v-\n", int(b[originRead-2]), int(b[originRead-1]))
		if clientWriteErr != nil && !strings.Contains(clientWriteErr.Error(), "remote error: tls: user canceledBAD") {
			break
		}
	}
	// END REAL WAY

	// TEST WAY
	// httpReq, httpErr := http.ReadRequest(bufReader)
	// if httpErr != nil {
	// 	fmt.Printf("httpErr: %+v\n", httpErr)
	// }
	// fmt.Printf("%+v\n", httpReq)

	// httpClient := http.Client{}
	// // httpReq.URL, _ = url.Parse("https://emanor-oie.oktapreview.com/oauth2/v1/token")
	// httpReq.URL, _ = url.Parse(fmt.Sprintf("https://emanor-oie.oktapreview.com%s", httpReq.URL))
	// httpReq.RequestURI = ""
	// httpResp, httpErr := httpClient.Do(httpReq)
	// httpResp.Proto = "HTTP/1.1"
	// httpResp.ProtoMajor = 1
	// httpResp.ProtoMinor = 1

	// httpResp.Header.Set("Connection", "keep-alive")
	// fmt.Printf("httpResp: %+v, \nhttpErr: %+v\n", httpResp, httpErr)

	// var buf bytes.Buffer // Create a new buffer
	// writer := io.Writer(&buf)
	// writeErr := httpResp.Write(writer)
	// if writeErr != nil {
	// 	fmt.Printf("%+v\n", writeErr)
	// }
	// fmt.Printf("\n\n%s\n\n", string(buf.Bytes()))
	// written, writeErr := tlsConn.Write(buf.Bytes())
	// if writeErr != nil {
	// 	fmt.Printf("%+v\n", writeErr)
	// }
	// fmt.Printf("written: %+v\n", written)

	// read, readErr = tlsConn.Read(b)
	// fmt.Printf("Read-1: %v, ReadErr: %v\n", read, readErr)

	// read, readErr = tlsConn.Read(b)
	// fmt.Printf("Read-2: %v, ReadErr: %v\n", read, readErr)

	// fmt.Printf("ConnectionState: %+v\n", tlsConn.ConnectionState())
	// // closeErr := tlsConn.Close()
	// // fmt.Printf("closeErr: %+v\n", closeErr)

	// // fmt.Printf("%+v\n", string(b))
	// // byteReader = bytes.NewReader(b)
	// // bufReader = bufio.NewReader(byteReader)
	// // httpReq, httpErr = http.ReadRequest(bufReader)
	// // if httpErr != nil {
	// // 	fmt.Printf("httpErr: %+v\n", httpErr)
	// // }
	// // fmt.Printf("%+v\n", httpReq)

	// /*
	// 	fmt.Printf("%+v\n", clientConn)
	// 	b := make([]byte, 4096)
	// 	r, err := clientConn.Read(b)
	// 	fmt.Printf("\nr:\n%+v\nb:\n%+v\nerr: %v\n", r, string(b[0:r]), err)

	// 	written, err := destConn.Write(b[0:r])
	// 	fmt.Printf("\nWritten: %v\nErr: %+v\n", written, err)
	// 	r, err = destConn.Read(b)
	// 	fmt.Printf("\nrb:\n%+v\nb:\n%+v\nerr: %v\n", r, string(b[0:r]), err)
	// 	written, err = clientConn.Write(b[0:r])
	// 	fmt.Printf("\nWrittenb: %v\nErr: %+v\n", written, err)

	// 	clientConn.SetReadDeadline(time.Now().Add(time.Second * 5))
	// 	fmt.Printf("%+v\n", time.Now().Add(time.Second*5))

	// 	r, err = clientConn.Read(b)
	// 	fmt.Printf("\nr2:\n%+v\nb:\n%+v\nerr: %v\n", r, string(b[0:r]), err)
	// 	fmt.Printf("%+v\n", destConn)
	// 	written, err = destConn.Write(b[0:r])
	// 	fmt.Printf("\nWritten2: %v\nErr: %+v\n", written, err)
	// 	r, err = destConn.Read(b)
	// 	fmt.Printf("\nr2b:\n%+v\nb:\n%+v\nerr: %v\n", r, string(b[0:r]), err)
	// 	written, err = clientConn.Write(b[0:r])
	// 	fmt.Printf("\nWritten2b: %v\nErr: %+v\n", written, err)

	// 	r, err = clientConn.Read(b)
	// 	fmt.Printf("\nr3:\n%+v\nb:\n%+v\nerr: %v\n", r, string(b[0:r]), err)
	// 	fmt.Printf("%+v\n", destConn)
	// 	written, err = destConn.Write(b[0:r])
	// 	fmt.Printf("\nWritten3: %v\nErr: %+v\n", written, err)
	// 	r, err = destConn.Read(b)
	// 	fmt.Printf("\nr3b:\n%+v\nb:\n%+v\nerr: %v\n", r, string(b[0:r]), err)
	// 	written, err = clientConn.Write(b[0:r])
	// 	fmt.Printf("\nWritten3b: %v\nErr: %+v\n", written, err)

	// 	// request, err := http.ReadRequest(readerWriter.Reader)
	// 	// fmt.Printf("Request:\n%+v\n", request)
	// 	time.Sleep(time.Second * 4)
	// 	fmt.Printf("\nCount: %v\n", readerWriter.Reader.Buffered())
	// */

	//END TEST WAY

	// rewrite := func(pr *httputil.ProxyRequest) {
	// 	pr.SetURL(req.URL)
	// 	// test SNI add host
	// 	pr.Out.Host = "emanor-oie.oktapreview.com" //sni //"gw.oktamanor.net"
	// }
	// proxy = &httputil.ReverseProxy{Rewrite: rewrite}
	// //proxy.ModifyResponse = modifyResponseImpl
	// proxy.Transport = http.DefaultTransport
	// // proxy.ServeHTTP(w, httpReq)
	//end testing

}

type contentType int

const (
	CHUNKED contentType = iota
	LENGTH
)

const (
	LF    byte = 10 // 0x0A
	CR    byte = 13 // 0x0D
	SP    byte = 32 // 0x20
	HTAB  byte = 9  // 0x09
	VT    byte = 11 // 0x0B
	FF    byte = 12 // 0x0C
	COLON byte = 58 // 0x3A

	ZERO    byte = 0x30
	NINE    byte = 0x39
	UPPER_A byte = 0x41
	UPPER_F byte = 0x46
	LOWER_A byte = 0x61
	LOWER_F byte = 0x66

	BUFFER_INC int = 2048
)

func test() {
	b := []byte("\r\n\r\n")
	fmt.Printf("== \\r = %v\n", b[0] == CR)
	fmt.Printf("== \\n = %v\n", b[1] == CR)
	fmt.Printf("== \\r = %v\n", b[0] == LF)
	fmt.Printf("== \\n = %v\n", b[1] == LF)
	// CRLF
}

type httpMessage struct {
	// req / stat line
	Method,
	Uri,
	Version,
	StatusCode,
	ReasonPhrase string

	Headers map[string]string

	ContentType contentType
	ContentStart,
	ContentEnd int

	RawMessage    []byte
	RawMessageLen int

	Error error
}

func readFromConnection(tlsConn *tls.Conn) httpMessage {
	// Max tcp packet size is 65k, typical network equipment restrict MTU to 1500 bytes
	// use 2048, if greater copy to bytebuffer as needed
	b := make([]byte, BUFFER_INC)
	httpMsg := httpMessage{}

	read, readErr := tlsConn.Read(b)
	fmt.Printf("Read: %v, ReadErr: %v\n", read, readErr)
	fmt.Printf("%+v\n", string(b))

	if read >= len(b) {
		buffer := bytes.Buffer{}
		buffer.Write(b)
		for {
			innerRead, readErr := tlsConn.Read(b)
			fmt.Printf("Read Extra: %v, ReadErr: %v\n", innerRead, readErr)
			fmt.Printf("%+v\n", string(b))
			buffer.Write(b[0:innerRead])
			read += innerRead
			if innerRead < BUFFER_INC {
				//b = buffer.Bytes()
				break
			}
		}
		fmt.Printf("\nFinal []byte size: %v\n", len(b))
		b = buffer.Bytes()
	}
	httpMsg.RawMessage = b
	httpMsg.RawMessageLen = read

	return httpMsg
}

func parseRequestMessage(msg []byte) httpMessage { //, msgL int) httpMessage {
	// Start Line
	httpMsg := httpMessage{}
	httpMsg.Headers = map[string]string{}
	index := 0
	if msg[1] == LF {
		if msg[0] == CR {
			index = 2
		} else {
			httpMsg.Error = fmt.Errorf("invalid start line, LF not followed by CR")
			return httpMsg
		}
	}
	index = readRequestStartLine(msg, index, &httpMsg)
	if httpMsg.Error != nil {
		log.Fatalf("readRequestStartLine: %v, index: %v\n\n", httpMsg.Error, index)
		return httpMsg
	}

	// Headers
	index += parseHeaders(msg[index:], &httpMsg)
	if httpMsg.Error != nil {
		log.Fatalf("parseHeaders: %v, index: %v\n\n", httpMsg.Error, index)
		return httpMsg
	}
	fmt.Println(index)

	// Body
	parseBody(msg, index, &httpMsg)

	fmt.Printf("\n\n%+v\n\n", httpMsg)

	return httpMsg
}

func parseResponseMessage(msg []byte) httpMessage {
	// Status Line
	httpMsg := httpMessage{}
	httpMsg.Headers = map[string]string{}
	index := 0
	if msg[1] == LF {
		if msg[0] == CR {
			index = 2
		} else {
			httpMsg.Error = fmt.Errorf("invalid status-line, LF not followed by CR")
			return httpMsg
		}
	}
	index = readResponseStartLine(msg, &httpMsg)
	if httpMsg.Error != nil {
		log.Fatalf("readRequestStartLine: %v, index: %v\n\n", httpMsg.Error, index)
		return httpMsg
	}

	// Headers
	index += parseHeaders(msg[index:], &httpMsg)
	if httpMsg.Error != nil {
		log.Fatalf("parseHeaders: %v, index: %v\n\n", httpMsg.Error, index)
		return httpMsg
	}
	fmt.Println(index)

	// Body
	// if httpMsg.ContentType == CHUNKED {
	// 	chunkSize := getHexDigit(msg[index:])
	// 	if chunkSize == -1 {
	// 		// handle error
	// 	}
	// 	bodyStart, err := readNextLine(msg[index:])
	// 	if err != nil {
	// 		//handle error
	// 	}
	// 	bodyStart++
	// 	httpMsg.ContentStart = index + bodyStart
	// 	httpMsg.ContentEnd = httpMsg.ContentStart + chunkSize
	// 	fmt.Printf("\n\n--%+v--\n\n\n", string(msg[httpMsg.ContentStart:httpMsg.ContentEnd]))
	// } else if httpMsg.ContentType == LENGTH {

	// }
	parseBody(msg, index, &httpMsg)

	fmt.Printf("\n\n%+v\n\n", httpMsg)
	return httpMsg
}

func parseBody(msg []byte, index int, httpMsg *httpMessage) {
	if httpMsg.ContentType == CHUNKED {
		chunkSize := getHexDigit(msg[index:])
		if chunkSize == -1 {
			// handle error
		}
		bodyStart, err := readNextLine(msg[index:])
		if err != nil {
			//handle error
		}
		bodyStart++
		httpMsg.ContentStart = index + bodyStart
		httpMsg.ContentEnd = httpMsg.ContentStart + chunkSize
		fmt.Printf("\n\n--%+v--\n\n\n", string(msg[httpMsg.ContentStart:httpMsg.ContentEnd]))
	} else if httpMsg.ContentType == LENGTH {
		// bodyStart, err := readNextLine(msg[index:])
		// if err != nil {
		// 	//handle error
		// }
		// bodyStart++
		httpMsg.ContentStart = index
		httpMsg.ContentEnd = httpMsg.ContentStart + httpMsg.ContentEnd
		fmt.Printf("\n\n--%+v--\n\n\n", string(msg[httpMsg.ContentStart:httpMsg.ContentEnd]))
	}
	httpMsg.RawMessage = msg
}

func processNextChunk() {

}

func readRequestStartLine(msg []byte, index int, httpMsg *httpMessage) int {
	newIndex := bytes.IndexByte(msg[index:], LF)
	if msg[newIndex-1] != CR {
		httpMsg.Error = fmt.Errorf("invalid header, LF not followed by CR")
		return -1
	}

	// Using strict SP https://httpwg.org/specs/rfc9112.html#request.line
	parts := bytes.Split(msg[index:newIndex], []byte{SP})
	if len(parts) != 3 {
		httpMsg.Error = fmt.Errorf("invalid start line, %s", string(msg[index:newIndex]))
		return -1
	}

	// only support specific methods
	method := string(parts[0])
	switch method {
	case "GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS":
		httpMsg.Method = method
	default:
		httpMsg.Error = fmt.Errorf("invalide method: %s", method)
		return -1
	}

	// not checking target / version for now
	httpMsg.Uri = string(parts[1])
	httpMsg.Version = string(parts[2])

	return newIndex + 1
}

func readResponseStartLine(msg []byte, httpMsg *httpMessage) int {
	newIndex := bytes.IndexByte(msg, LF)
	if msg[newIndex-1] != CR {
		httpMsg.Error = fmt.Errorf("invalid status-line, LF not followed by CR")
		return -1
	}

	// Using strict SP https://httpwg.org/specs/rfc9112.html#status.line
	parts := bytes.Split(msg[:newIndex], []byte{SP})
	if len(parts) != 3 {
		httpMsg.Error = fmt.Errorf("invalid status-line, %s", string(msg[:newIndex]))
		return -1
	}
	httpMsg.Version = string(parts[0])
	httpMsg.StatusCode = string(parts[1])
	httpMsg.ReasonPhrase = string(parts[2])

	return newIndex + 1
}

func parseHeaders(msg []byte, httpMsg *httpMessage) int {
	curIndex := 0
	for {
		newIndex, err := readNextLine(msg[curIndex:])
		if err != nil {
			httpMsg.Error = err
			return -1
		}
		newIndex += curIndex
		fmt.Printf("curIndex=%v ,newIndex=%v, isNewLine(msg[curIndex], msg[newIndex])=%v\n", curIndex, newIndex, isNewLine(msg[curIndex], msg[newIndex]))
		if isNewLine(msg[curIndex], msg[newIndex]) {
			break
		}
		colon := bytes.IndexByte(msg[curIndex:newIndex], COLON)
		if colon == -1 {
			httpMsg.Error = fmt.Errorf("invalid header, no colon: %s", string(msg[curIndex:newIndex]))
			return -1
		}
		colon += curIndex
		/*
		 * MIGHT CHANGE SO httpMessage keeps everything as []byte instead of string
		 */
		key := string(msg[curIndex:colon])
		valStart := colon + 1
		valEnd := newIndex - 2
		if isOWS(msg[valStart]) {
			valStart++
		}
		if isOWS(msg[valEnd]) {
			valEnd--
		}
		// TODO - check for bare CR
		val := string(msg[valStart : valEnd+1])
		fmt.Printf("-%s-%s-\n", key, val)
		// TODO Headers should be [][] to handle multiple set-cookie in response
		httpMsg.Headers[key] = val

		if strings.ToLower(key) == "content-length" {
			httpMsg.ContentEnd, _ = strconv.Atoi(val)
			httpMsg.ContentType = LENGTH
		} else if strings.ToLower(key) == "transfer-encoding" {
			httpMsg.ContentType = CHUNKED
		}

		curIndex = newIndex + 1
	}

	return curIndex + 2
}

func readNextLine(msg []byte) (int, error) {
	// field-line   = field-name ":" OWS field-value OWS
	if isNewLine(msg[0], msg[1]) {
		return 1, nil
	}
	newIndex := bytes.IndexByte(msg, LF)
	if newIndex == -1 || msg[newIndex-1] != CR {
		error := fmt.Errorf("invalid header, LF not proceeded by CR")
		fmt.Printf("\n\nindex: %v, newIndex: %v\n", 0, newIndex)
		fmt.Printf("%v\n\n", string(msg[0:newIndex]))
		return -1, error
	}
	if isOWS(msg[0]) {
		error := fmt.Errorf("invalid header, starts with whitespace")
		return -1, error
	}

	return newIndex, nil
}

func getHexDigit(b []byte) int {
	for i := 0; i < len(b); i++ {
		if (b[i] >= ZERO && b[i] <= NINE) || (b[i] >= LOWER_A && b[i] <= LOWER_F) || (b[i] >= UPPER_A && b[i] <= UPPER_F) {
			continue
		}
		if i == 0 {
			return -1
		}
		hexVal, err := strconv.ParseInt(string(b[0:i]), 16, 64)
		if err != nil {
			return -1
		}
		return int(hexVal)
	}
	return -1
}

func isOWS(b byte) bool {
	// SP, HTAB, VT (%x0B), FF (%x0C), or bare CR
	if b == SP || b == HTAB || b == VT || b == FF || b == CR {
		return true
	}
	return false
}

func isNewLine(cr, lf byte) bool {
	if cr == CR && lf == LF {
		return true
	} else {
		return false
	}
}

func transfer(destination io.WriteCloser, source io.ReadCloser) {
	defer destination.Close()
	defer source.Close()
	_, err := io.Copy(destination, source)
	if err != nil {
		fmt.Println(err)
	}
}

func main() {
	test()
	proxyHandler := ProxyHandler{}
	server := &http.Server{
		Addr:    ":8080",
		Handler: proxyHandler,
	}
	err := server.ListenAndServe()
	if err != nil {
		panic(err)
	}
}

// Function to load the root certificate and key
func loadRootCert(certPath, keyPath string) (*x509.Certificate, interface{}, error) {
	// Load root certificate
	certFile, err := os.ReadFile(certPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to open root certificate: %w", err)
	}
	block, _ := pem.Decode(certFile)
	if block == nil || block.Type != "CERTIFICATE" {
		fmt.Printf("Error: pem.Decode(): block: %+v\n", block)
	}
	rootCert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse root certificate: %w", err)
	}

	// Load root key
	keyFile, err := os.ReadFile(keyPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to open root key: %w", err)
	}
	block, _ = pem.Decode(keyFile)
	if block == nil || block.Type != "PRIVATE KEY" {
		fmt.Printf("Error: pem.Decode(): block: %+v\n", block)
	}
	// fmt.Printf("Bloick Type: %+v\n", block.Type)
	rootKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse root private key: %w", err)
	}

	return rootCert, rootKey, nil
}

// Generate a new leaf certificate signed by the root certificate
func generateLeafCertificate(rootCert *x509.Certificate, rootKey *rsa.PrivateKey) (*x509.Certificate, []byte, *rsa.PrivateKey, error) {
	// Create a new leaf certificate template
	leafTemplate := x509.Certificate{
		SerialNumber: big.NewInt(time.Now().UnixNano()),
		//"ST=California, CN=*.oktapreview.com, O="Okta, Inc.", L=San Francisco, C=US"
		Subject: pkix.Name{
			Country:      []string{"US"},
			Organization: []string{"Okta, Inc."},
			Province:     []string{"California"},
			Locality:     []string{"San Francisco"},
			CommonName:   "*.oktapreviwe.com",
			// CommonName: "gw.oktamanor.net",
		},
		NotBefore:   time.Now(),
		NotAfter:    time.Now().Add(365 * 24 * time.Hour), // valid for 1 year
		KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageDataEncipherment,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		DNSNames:    []string{"*.oktapreview.com", "oktapreview.com"},
		// DNSNames:              []string{"gw.oktamanor.net"},
		BasicConstraintsValid: true,
	}

	// Generate a new key pair for the leaf certificate
	leafKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to generate leaf key pair: %w", err)
	}

	// Create the leaf certificate by signing it with the root private key
	leafCertBytes, err := x509.CreateCertificate(rand.Reader, &leafTemplate, rootCert, &leafKey.PublicKey, rootKey)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to create leaf certificate: %w", err)
	}
	// pkcs12.
	// Parse the generated certificate
	leafCert, err := x509.ParseCertificate(leafCertBytes)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to parse leaf certificate: %w", err)
	}

	return leafCert, leafCertBytes, leafKey, nil
}
